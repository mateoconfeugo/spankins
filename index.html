<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Spankins : a Jenkins inspired continuous integration server and DSL">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Spankins</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/mateoconfeugo/spankins">View on GitHub</a>

          <h1 id="project_title">Spankins</h1>
          <h2 id="project_tagline">a Jenkins inspired continuous integration server and DSL</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/mateoconfeugo/spankins/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/mateoconfeugo/spankins/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <ul>
<li>
<p>Why?
some of the problems with jenkins:</p>

<ol>
<li>very general purpose; therefore, heavy to do lightweight tasks</li>
<li>difficult to version control the server side of jenkins</li>
<li>jenkins is largerly defined by your set of plug ins.</li>
<li>The dirty secret is jenkins writes to a file and shells out to that ...weak!</li>
<li>less control of most things plugins offer then using the api's directly</li>
<li>Its not a simple to understand program</li>
<li>So many steps</li>
<li>difficult for developers to run on their own.</li>
<li>We should be simplifing the process not adding to the complexity</li>
</ol>

<p>The hope of all this is</p>
</li>
<li><p>Simple to understand continuous integration program that is flexibly and easy to maintain and understand</p></li>
<li>   Lightweight -  okay,  its running on the jvm but compared to a typical jenkins install with all its plugins</li>
<li>   Very fast compared to anything.</li>
<li>   Easy to make new job types out of function graphs and easy to customize these types.</li>
<li>   Everything in one language clojure versus jenkins java, jelly, xml, groovy</li>
<li>   Plugins are just functions/graphs</li>
<li>   Debuggable</li>
<li>   Work on interactively</li>
<li>
<p>Handle very high concurrent load</p>

<p>Things to note.</p>

<ul>
<li>hierarchy of composable maps results in a customized "jenkins job"</li>
<li>cascading hierarcies achieved using multimethods</li>
</ul>

<p>The control level of the software uses channel operation fuctions.</p>
</li>
</ul>

<h2>
<a id="terms" class="anchor" href="#terms" aria-hidden="true"><span class="octicon octicon-link"></span></a>Terms</h2>

<h3>
<a id="server" class="anchor" href="#server" aria-hidden="true"><span class="octicon octicon-link"></span></a>Server</h3>

<ul>
<li>Server doesn't do any job specific stuff all of that is left to the invoked compiled function graphs (ICFG).  Similar to jenkins and its plugins</li>
<li>The jenkins server deals with the passing around and management of the channls (i.e. the control logic)</li>
<li>Running the job functions from a pallet group spec can allow each job to be easily run in its own docker container</li>
<li>
<p>"Jenkins" server stuff is mainly built using core.async core.match  function graph and pallet if necessary</p>

<p>So how does this work</p>

<ol>
<li>Developer check in code and triggers a hook</li>
<li>The commit hash is sent via the hook to a rest api</li>
<li>The "jenkins"-lite server takes this commit and project and builds a function graph</li>
<li>the function graph is sent into the dispatch channel</li>
<li>The dispatcher receives the function graph and hooks it up to a new output channel forming a tuple</li>
<li>This tuple is passed to the processing channel</li>
<li>The processing channel runs the function graph in a seperate thread</li>
<li>Upon returning the function graphs results are sent to the output results channel</li>
<li>The "jenkins"-lite server takes these results and</li>
</ol>
</li>
</ul>

<h3>
<a id="dsl" class="anchor" href="#dsl" aria-hidden="true"><span class="octicon octicon-link"></span></a>DSL</h3>

<p>A set of composable macros that build out the stages of the jobs workflow and in the end create a job graph</p>

<h3>
<a id="job-graph" class="anchor" href="#job-graph" aria-hidden="true"><span class="octicon octicon-link"></span></a>Job Graph</h3>

<p>A job is a combination of a channels hooked up together in a workflow via a function graph.</p>

<p>no extra technology just a simple extendable distributed programs for running the relivant commands in the right environment
  since each step relies on the previous results we can use a function graph.  Viewing the building of a jenkins job as function graph calling of a compiled function graph provides a lightweight framework within which you place your various jenkins type activities.</p>

<ul>
<li>The raw job can passed to and returned from functions and channels</li>
<li>The job graphs return immediately when the compiled function is called.<br>
</li>
<li>All the synchronization of the build work flow a job specifies is done through channels.</li>
<li>Communication  between stages happens via the channels.</li>
<li>
<p>The job graph keys may be channels, maps of channels or any other clojure data structure.</p>

<p>selecting a branch
cloning git repo
compiling
triggering other builds
unit testing
component testing
acceptance testing
generating reports
deploying applications
emailing/messaging/storing results</p>

<p>Instead of using a complicated mix of plugins we try to use  clojure libraries and mechanisms in the language itself to replicate the functionality of jenkins.</p>
</li>
</ul>

<h2>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h2>

<p>One of the nice things is that when you build a job by invoking the compiled function graph is that it returns almost immediately.</p>

<p>We need to define what happens where:</p>

<ul>
<li><p>In the job, channels are used to pass information between the different stages a job has through out its life cycle to coordinate the synchronization of sequential operation.</p></li>
<li><p>In the server infromation about the jobs is sent to centralized location.</p></li>
<li><p>Since a job is represented as a clojure map of defnk type functions  we can easily move this around to different workers
that then get compiled and run in the containing environment</p></li>
<li><p>A compiled graph function when run is a complete state machine transforming in a series of well defined steps an artifact into anothor artifact or action result.</p></li>
<li><p>The server upon when distributing work dispatches the job along with a channel that streams the job information back to the server.</p></li>
</ul>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h2>

<p>Copyright Â© 2014 FIXME</p>

<p>Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Spankins maintained by <a href="https://github.com/mateoconfeugo">mateoconfeugo</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
