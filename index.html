<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Spankins by mateoconfeugo</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Spankins</h1>
        <p>a jenkins inspired continuous integration server</p>

        <p class="view"><a href="https://github.com/mateoconfeugo/spankins">View the Project on GitHub <small>mateoconfeugo/spankins</small></a></p>


        <ul>
          <li><a href="https://github.com/mateoconfeugo/spankins/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/mateoconfeugo/spankins/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/mateoconfeugo/spankins">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <ul>
<li>
<p>Why?
some of the problems with jenkins:</p>

<ol>
<li>very general purpose; therefore, heavy to do lightweight tasks</li>
<li>difficult to version control the server side of jenkins</li>
<li>jenkins is largerly defined by your set of plug ins.</li>
<li>The dirty secret is jenkins writes to a file and shells out to that ...weak!</li>
<li>less control of most things plugins offer then using the api's directly</li>
<li>Its not a simple to understand program</li>
<li>So many steps</li>
<li>difficult for developers to run on their own.</li>
<li>We should be simplifing the process not adding to the complexity</li>
</ol>
<p>The hope of all this is</p>
</li>
</ul><ul>
<li>   Simple to understand continuous integration program that is flexibly and easy to maintain and understand</li>
<li>   Lightweight -  okay,  its running on the jvm but compared to a typical jenkins install with all its plugins</li>
<li>   Very fast compared to anything.</li>
<li>   Easy to make new job types out of function graphs and easy to customize these types.</li>
<li>   Everything in one language clojure versus jenkins java, jelly, xml, groovy</li>
<li>   Plugins are just functions/graphs</li>
<li>   Debuggable</li>
<li>   Work on interactively</li>
<li>
<p>Handle very high concurrent load</p>

<p>Things to note.</p>

<ul>
<li>hierarchy of composable maps results in a customized "jenkins job"</li>
<li>cascading hierarcies achieved using multimethods</li>
</ul>
<p>The control level of the software uses channel operation fuctions.</p>
</li>
</ul><h2>
<a name="terms" class="anchor" href="#terms"><span class="octicon octicon-link"></span></a>Terms</h2>

<h3>
<a name="server" class="anchor" href="#server"><span class="octicon octicon-link"></span></a>Server</h3>

<ul>
<li>Server doesn't do any job specific stuff all of that is left to the invoked compiled function graphs (ICFG).  Similar to jenkins and its plugins</li>
<li>The jenkins server deals with the passing around and management of the channls (i.e. the control logic)</li>
<li>Running the job functions from a pallet group spec can allow each job to be easily run in its own docker container</li>
<li>
<p>"Jenkins" server stuff is mainly built using core.async core.match  function graph and pallet if necessary</p>

<p>So how does this work</p>

<ol>
<li>Developer check in code and triggers a hook</li>
<li>The commit hash is sent via the hook to a rest api</li>
<li>The "jenkins"-lite server takes this commit and project and builds a function graph</li>
<li>the function graph is sent into the dispatch channel</li>
<li>The dispatcher receives the function graph and hooks it up to a new output channel forming a tuple</li>
<li>This tuple is passed to the processing channel</li>
<li>The processing channel runs the function graph in a seperate thread</li>
<li>Upon returning the function graphs results are sent to the output results channel</li>
<li>The "jenkins"-lite server takes these results and</li>
</ol>
</li>
</ul><h3>
<a name="dsl" class="anchor" href="#dsl"><span class="octicon octicon-link"></span></a>DSL</h3>

<p>A set of composable macros that build out the stages of the jobs workflow and in the end create a job graph</p>

<h3>
<a name="job-graph" class="anchor" href="#job-graph"><span class="octicon octicon-link"></span></a>Job Graph</h3>

<p>A job is a combination of a channels hooked up together in a workflow via a function graph.</p>

<p>no extra technology just a simple extendable distributed programs for running the relivant commands in the right environment
  since each step relies on the previous results we can use a function graph.  Viewing the building of a jenkins job as function graph calling of a compiled function graph provides a lightweight framework within which you place your various jenkins type activities.</p>

<ul>
<li>The raw job can passed to and returned from functions and channels</li>
<li>The job graphs return immediately when the compiled function is called.<br>
</li>
<li>All the synchronization of the build work flow a job specifies is done through channels.</li>
<li>Communication  between stages happens via the channels.</li>
<li>
<p>The job graph keys may be channels, maps of channels or any other clojure data structure.</p>

<p>selecting a branch
cloning git repo
compiling
triggering other builds
unit testing
component testing
acceptance testing
generating reports
deploying applications
emailing/messaging/storing results</p>

<p>Instead of using a complicated mix of plugins we try to use  clojure libraries and mechanisms in the language itself to replicate the functionality of jenkins.</p>
</li>
</ul><h2>
<a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Usage</h2>

<p>One of the nice things is that when you build a job by invoking the compiled function graph is that it returns almost immediately.</p>

<p>We need to define what happens where:</p>

<ul>
<li><p>In the job, channels are used to pass information between the different stages a job has through out its life cycle to coordinate the synchronization of sequential operation.</p></li>
<li><p>In the server infromation about the jobs is sent to centralized location.</p></li>
<li><p>Since a job is represented as a clojure map of defnk type functions  we can easily move this around to different workers
that then get compiled and run in the containing environment</p></li>
<li><p>A compiled graph function when run is a complete state machine transforming in a series of well defined steps an artifact into anothor artifact or action result.</p></li>
<li><p>The server upon when distributing work dispatches the job along with a channel that streams the job information back to the server.</p></li>
</ul><h2>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>License</h2>

<p>Copyright Â© 2014 FIXME</p>

<p>Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/mateoconfeugo">mateoconfeugo</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>