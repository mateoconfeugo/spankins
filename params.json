{"name":"Spankins","tagline":"a Jenkins inspired continuous integration server and DSL","body":"spankins\r\n========\r\n\r\nContinuous Integration/Delivery/Deployment Domain Specific Language (DSL) runnning in the context of a forked github webapp server project.\r\n\r\n**Contents**\r\n\r\n* [Overview](#overview)\r\n* [Installation](#installation)\r\n* [Motivation?](#motivation)\r\n* [DSL](#dsl)\r\n* [Explanation?](#explanation)\r\n* [Deep Code Walking Macros](#dcwm)\r\n* [Reading](#reading)\r\n* [Terminology](#terminology)\r\n\r\n<a name=\"overview\">\r\n## Overview\r\n\r\nExample of a DSL to perform a dev-ops type task:\r\n\r\nThis particular task upon a commit to a branch in git hub create an uberjar and deploy the uberjar emailing and creating the neccessary reports.\r\n\r\n```clojure\r\n(ns my.ns\r\n  (:require [spankins.core :refer :all]))\r\n\r\n\r\n  (def ci-spec (job\r\n                (parameters :commit :release)\r\n                (scm :git (:commit parameters))\r\n                (build\r\n                 (step\r\n                     (>! monitor \"compiling app\")\r\n                     (pprint \"lein compile\"))\r\n                 (step (pprint \"lein test\"))\r\n                 (step (pprint \"lein uberjar\"))\r\n                 (step (pprint \"lein deploy private\"))\r\n                 (step (pprint \"lien pallet up\")))\r\n                 (publishers\r\n                   (publish (email \"a@b.com\"))\r\n                   (publish (report\r\n                               (let [results (<! build-results)]\r\n                                 create-report))))))\r\n```\r\n\r\n<a name=\"installation\">\r\n## Installation\r\n```\r\n[spankins \"0.1.0\"]\r\n```\r\n\r\n<a name=\"motivation\">\r\n## Motivation\r\n  largerly an out growth of frustration using jenkins:\r\n\r\n  - very general purpose; therefore, heavy to do lightweight tasks\r\n  - difficult to version control the server side of jenkins\r\n  - jenkins is largerly defined by your set of plug ins.\r\n  - The dirty secret is jenkins writes to a file and shells out to that ...weak!\r\n  -. less control of most things plugins offer then using the api's directly\r\n  - Its not a simple to understand program\r\n  - So many steps\r\n  - difficult for developers to run on their own.\r\n  - We should be simplifing the process not adding to the complexity\r\n  - Command line tools are slow and limited.\r\n\r\n  The hope of all this is\r\n  - Simple to understand continuous integration program that is flexibly and easy to maintain and understand\r\n  - Lightweight -  okay,  its running on the jvm but compared to a typical jenkins install with all its plugins\r\n  - Very fast compared to anything.\r\n  - Easy to make new job types out of function graphs and easy to customize these types.\r\n  - Everything in one language clojure versus jenkins java, jelly, xml, groovy\r\n  - Plugins are just functions/graphs\r\n  - Debuggable/REPL I use cider\r\n  - Work on interactively\r\n  - Handle very high concurrent load\r\n  - A living piece of software that you improve and customize but there is no magic places.\r\n  - A versionable, rollbackable configuration system.\r\n\r\nThings to note.\r\n  * hierarchy of composable maps results in a customized \"jenkins job\"\r\n  * cascading hierarcies achieved using multimethods\r\n\r\n## Parts of the Solution\r\n=======\r\n  The control level of the software uses channel operation fuctions.\r\n\r\n## Terms\r\n\r\n\r\n### Server\r\n* Server doesn't do any job specific stuff all of that is left to the invoked compiled function graphs (ICFG).  Similar to jenkins and its plugins\r\n* The jenkins server deals with the passing around and management of the channls (i.e. the control logic)\r\n* Running the job functions from a pallet group spec can allow each job to be easily run in its own docker container\r\n* \"Jenkins\" server stuff is mainly built using core.async core.match  function graph and pallet if necessary\r\n\r\n  So how do this work\r\n  - Developer check in code and triggers a hook\r\n  - The commit hash is sent via the hook to a rest api\r\n  - The \"jenkins\"-lite server takes this commit and project and builds a function graph\r\n  - the function graph is sent into the dispatch channel\r\n  - The dispatcher receives the function graph and hooks it up to a new output channel forming a tuple\r\n  - This tuple is passed to the processing channel\r\n  - The processing channel runs the function graph in a seperate thread\r\n  - Upon returning the function graphs results are sent to the output results channel\r\n  - The \"jenkins\"-lite server takes these results and\r\n\r\n### How do you uses this?\r\n\r\nOne of the central ideas of this approach is that a use of this program forks this projects and ads there changes as adaptations to the code.   This way there aren't any plugins just include the library in the project dependencies and use it as you see fit.  The point of the DSL is that it is runable code and can be part of an application. This application is for managing your infrastructure.\r\n\r\n<a name=\"dsl\">\r\n# DSL\r\n\r\nA set of composable macros that build out the stages of the jobs workflow and in the end create a job graph\r\n\r\n\r\n## Job Graph\r\nA job is a combination of a channels hooked up together in a workflow via a function graph.\r\n\r\n* selecting a branch\r\n* cloning git repo\r\n* compiling\r\n* triggering other builds\r\n* unit testing\r\n* component testing\r\n* acceptance testing\r\n* generating reports\r\n* deploying applications\r\n* emailing/messaging/storing results\r\n\r\n  Each of these stages can be implemented in a go block and perhaps within a  while loop that will terminate\r\n  as a result of completing an action or receiving a control message from a channel or a channel closing.\r\n\r\nThe building of a jenkins job as invoking a compiled job graph function\r\nChannels are some of the things returned from function call.\r\nThese channels are used to communicate with job.\r\n\r\nProvides a lightweight framework within which you place no extra technology just a simple extendable distributed programs for running the relivant commands in the right environment  since each step relies on the previous results we can use a function graph.  Viewing the building of a jenkins job as function graph calling of a compiled function graph provides a lightweight framework within which you place your various jenkins type activities.\r\n\r\n\r\n* The raw job can passed to and returned from functions and channels\r\n* The job graphs return immediately when the compiled function is called.\r\n* All the synchronization of the build work flow a job specifies is done through channels.\r\n* Communication  between stages happens via the channels.\r\n* The job graph keys may be channels, maps of channels or any other clojure data structure.\r\n\r\n\r\n  The function returns almost immediately; however, within on function calls multiple\r\n  go routines may have been started and are running.\r\n\r\n  Interacting with these running jobs is accomplished by sending and recieving messages via\r\n  the channels returned from the function call.\r\n\r\nInstead of using a complicated mix of plugins we try to use clojure libraries and mechanisms in the\r\nlanguage itself to replicate the functionality of jenkins.\r\n\r\n\r\n## Usage\r\n\r\nOne of the nice things is that when you build a job by invoking the compiled function graph is that it returns almost immediately.\r\n\r\nWe need to define what happens where:\r\n\r\n* In the job, channels are used to pass information between the different stages a job has through out its life cycle to coordinate the synchronization of sequential operation.\r\n\r\n*  In the server infromation about the jobs is sent to centralized location.\r\n\r\n*  Since a job is represented as a clojure map of defnk type functions  we can easily move this around to different workers\r\n   that then get compiled and run in the containing environment\r\n\r\n* A compiled graph function when run is a complete state machine transforming in a series of well defined steps an artifact into anothor artifact or action result.\r\n\r\n* The server upon when distributing work dispatches the job along with a channel that streams the job information back to the server.\r\n\r\n  ## How the DSL works\r\n\r\n  The audience for this DSL is devops engineers who need to create\r\n  complex automated asynchronous workflows comprising of many tasks.\r\n\r\n  Often devops tasks take a lot of time with many parts. Most of the time is spent\r\n  setting up environments, compiling and moving data around - the\r\n  actual logic that sets these things in motion is fairly small and\r\n  executes quickly.\r\n\r\n  This continuous itegration/delivery job macro set simplifies the process\r\n  of writing asynchronous ci related tasks by providing  a customized language.\r\n  devops engineers can check this in and use it with other code.\r\n\r\n  Extending the clojure language allows ci related tasks to be\r\n  integrated into the rest of the infrastructure orchastration as needed.\r\n  There is no need for a centralized server although this is possible if that\r\n  is what is desire (usually it is)\r\n\r\n  The extendsions to the language to create the dsl using macros<1>,\r\n  function graphs <3A,B> go routines and channels<1>\r\n\r\n  LAYERS in DSL-driven system.\r\n\r\n  ```\r\n\r\n  ----------------------------------------------------------------------\r\n   <6>                         Domain Specific code\r\n  ----------------------------------------------------------------------\r\n   <5>                         Runtime for DSL code\r\n  ----------------------------------------------------------------------\r\n   <4>       Higher-level entities   - A: data and B: control\r\n  ----------------------------------------------------------------------\r\n   <3> A: Domain-specific data structures | B: Domain-specific control structures\r\n  ----------------------------------------------------------------------\r\n   <2>                    Low-lev domain primitives\r\n  ----------------------------------------------------------------------\r\n   <1>                          Clojure\r\n  ----------------------------------------------------------------------\r\n  ```\r\n\r\n  The dsl spec <6> creates a workflow function <4>\r\n  This function, when invoked will create an instance of a set of\r\n  communicating sequential processes that implement the asynchronous workflow  <5>.\r\n  The communication sequeantial processes are implemented using channels and go routines <1>.\r\n\r\n  The worflow function <4> is non-blocking and returns the running job <5> immediately in the form of a map <3>\r\n  This map <3> has keys some which are properties others which are channels.\r\n  The workflow communicates with its environment via these channels\r\n\r\n  The as the workflow job progresses it passes messages\r\n  These messages <3A> contain data and sometimes channels\r\n\r\n  Along with expanding out all the pieces of user supplied dsl, the job macro\r\n  inserts a dispatcher <3B> that handles all the control logic.\r\n\r\n  The dispatcher <3B> stitches together the auxliary channel handling with the user\r\n  specified dsl forms<2>\r\n\r\n\r\n\r\n  ----------------------------------------------------------------------\r\n   <6> Domain Specific code\r\n   ```clojure\r\n       (job :some-job\r\n            (build\r\n               (step  (>! $monitor  {:message :ping}))))\r\n   ```\r\n  ----------------------------------------------------------------------\r\n   <5> Runtime for DSL code:\r\n   (def job-obj (new-some-job {:settings nil}))\r\n   (def run-results (build job-object parameters))\r\n\r\n  ----------------------------------------------------------------------\r\n   <4>       Higher-level entities   - A: data and B: control\r\n   ```clojure\r\n    (def job-graph {:parameters (fnk [commit-hash] {:commit comit-hash})\r\n                    :input (chan)\r\n                    :output (chan)\r\n                    :error (chan)\r\n    ```\r\n\r\n     There need to be some rules that reflect the causal nature of reality.\r\n     scm releated activies must preceed build activies that must preceed publish\r\n     process.\r\n     These things are inherent in a sequential workflow process.\r\n\r\n     This is a degenerate case; however, with channels it is possible to introduce\r\n     feedback into this system such that up building and having the build step fail\r\n     it could prompt the scm sequence task to run again if there is a new version of\r\n     release next and try to continue the build from there.\r\n\r\n  ----------------------------------------------------------------------\r\n   <3> A: Domain-specific data structures | B: Domain-specific control structures\r\n\r\n    The job is a set of tasks executed in sequence, each part in the sequence\r\n    is realized by a (fnk[] (go (while true (do ~@stuff))))  lets call them\r\n    fnking go do stuff functions (FGDSF) type connected\r\n    to a map key.  This map  will yield a set of channels for the sequence\r\n\r\n    ```clojure\r\n    {:input in\r\n     :output out\r\n     :error error}\r\n     ```\r\n\r\n     So this what each of the fnking go do stuff functions runs an endless\r\n    loop hosted in a go routine but the function returns immediately a map\r\n    of three channels\r\n\r\n    The parameters that can be passed into a build of a job are described as vector of keyworks\r\n    (parameters [:commit-hash :time :use-spot-instance?])\r\n\r\n    Intermediate data structure:\r\n    This is what gets generated as the DSL is walked.  It is from this that the function graphs\r\n    is constructed.\r\n\r\n    ```\r\n    (def materials {:in (chan)\r\n     :out (chan)\r\n     :error (chan)\r\n     :monitor (chan)\r\n     :parameters [:commit-hash :time :use-spot-instance?]\r\n     :properties [:environment]\r\n     :build {:steps [...]}\r\n     :publisher [...]})\r\n\r\n    (def job-spec-graph (build-job-graph materials))\r\n    ```\r\n\r\n   B:\r\n    Message Package [:event-token {:message }]\r\n    This gets put into and taken from channels\r\n\r\n   The dispatcher gets the message package along with channel that sent\r\n   the message.\r\n\r\n   Channels are used to route the data between the different workflow\r\n   processes (go routines).\r\n\r\n   The message package's event token is what will trigger the dispatch\r\n   routing.\r\n\r\n   These go routines are started when the compiled function graph is run\r\n   each of these functions will run listening to its input channels and\r\n   returning the the results of its processing into the output\r\n\r\n   Fking go do stuff  for a while functions:\r\n\r\n   This is where the magic offered by the dsl is realized.\r\n\r\n  ----------------------------------------------------------------------\r\n   <2>                    Low-lev domain primitives\r\n    core.async - channels, go routines\r\n    plumbing.graph - dnk, function graphs\r\n    core.match - dispatch table\r\n\r\n  ----------------------------------------------------------------------\r\n   <1>                          Clojure\r\n   Actual code of doing the task.  Everything else is convience and idomatic\r\n   easy of passing data and control to the appropriate sequence.\r\n\r\n\r\n  ----------------------------------------------------------------------\r\n<a name=\"explanation>\r\n## Explanation\r\n\r\n  Lisp is a local maximum in the space of programming languages, because it can do arbitary code transformation\r\n  of clojure code using clojure itself.\r\n\r\n  The idea is not that lisps are the right language for any particular problem but that\r\n  clojure encorages solving problems by creating new micro languages tailored to solve that problem<6>\r\n\r\n  This approach allow us to not only solve the immediate problem we started out to solve but also\r\n  with a whole class of problems in that domain.\r\n\r\n  This approach creates Meta linquistic abstractions - the approach of creating a domain specific language\r\n  that's then used to solve the problem at hand.\r\n\r\n  The hope is that this leaves us with a system that is highly flexibly and maintainable while staying\r\n  small and eaier to understand and debug\r\n\r\n  Clojure macros help presenting abstractions as a convenient feture of the language (bottom up driven development).\r\n  A DSL wraps domain abstractions in a layer of language.\r\n\r\n  What gets created at the end of such a bottom up process is a rich set of primativess,<2>\r\n  opertors, and forms for combinations that closely models the business domain<6>\r\n\r\n  To do the needful when creating a DSL we must look not only at top-level expression,<4><3><2>\r\n  but also at all the internal expression forms\r\n\r\n  The output of the job macro is as a clojure map of defnk type functions <3A,B>.\r\n  This is easily moved this around to different workers that then get compiled and run in the containing environment.\r\n\r\n  The job dsl is a set of deep walking macros. It doesn't just evaluate its top level form\r\n  but descends into its children and keeps going deeper.\r\n\r\n  in order to cover all the different cases we want to be able to have our job work for things besides\r\n  defn as well: do, fn, let, loop, when, letfn are places it makes sense to have our job in place.\r\n\r\n  <a name=\"dcwm\">\r\n  ### Background DEEP CODE WALKING MACRO TECHNIQUES:\r\n\r\n  Abstract Syntax Tree.\r\n  This pattern is to read forms into a map of nested clojure data structures\r\n  do some transforms on that structure and spit out forms generated from the data.\r\n  Reads in the form into a staging type data structure, do the transforms on the  data structure of forms,  and\r\n  create clojure code from transform\r\n\r\n    Additive transformations:\r\n  This type of macro takes an expression and augmented it with additional stuff\r\n  in a particular fashion creating some data structure/form/verb\r\n\r\n  In place transformations:\r\n  Transform the expression as it’s traversed\r\n\r\n  We will use all three\r\n  <1> Parses the form into an abstract syntax tree [channel, map, symbol]\r\n  <2> Take the AST and organize it into a function graph that connects the\r\n      channels together in a ci build workflow.\r\n  <3> Transforming reads/writes to channels into the [:token {:message {}}]\r\n      format.\r\n\r\n  Seperating the process of converting the dsl into two teps allows the parameters,\r\n  intialization data and auxliary channels [monitor log input error output] to be\r\n  created at the beginning of the function graph thus available to subsequent steps\r\n  that will be responding to input at run time.\r\n\r\n  The job builder modules are executed in sequence.\r\n\r\n  Generally the sequence is:\r\n  parameters/properties\r\n  scm\r\n  triggers\r\n  wrappers\r\n  prebuilders (lein only, configured like Builders)\r\n  builders (maven, freestyle, matrix, etc..)\r\n  postbuilders (maven only, configured like Builders)\r\n  publishers/reporters/notifications\r\n\r\n=======\r\n\r\n## License\r\n\r\nCopyright © 2014 FIXME\r\n\r\nDistributed under the Eclipse Public License either version 1.0 or (at\r\nyour option) any later version.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}